<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bookshelf Search</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Tesseract.js for OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  <style>
    :root {
      --bg-dark: #111;
      --white: #fff;
      --accent: #ff7a1a;
      --input-bg: #fff;
      --input-text: #111;
      --shadow-soft: 0 12px 30px rgba(0, 0, 0, 0.35);
      --transition-fast: 150ms ease-out;
      --transition-med: 250ms ease-out;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Helvetica Neue", Arial, sans-serif;
      background: #000;
      color: var(--white);
    }

    body {
      display: flex;
      justify-content: center;
      align-items: stretch;
      background: #000;
    }

    #app {
      position: relative;
      width: 100%;
      height: 100%;
      max-width: 480px;
      margin: 0 auto;
      background: #000;
      overflow: hidden;
    }

    .screen {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      background: #000;
    }

    .screen.active {
      display: flex;
    }

    /* ADD IMAGE SCREEN */

    #screen-add {
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    #screen-add-inner {
      text-align: center;
    }

    #screen-add h1 {
      font-size: 2.4rem;
      margin-bottom: 1.5rem;
    }

    #btn-add-image {
      background: var(--accent);
      border: none;
      color: #fff;
      padding: 16px 32px;
      border-radius: 999px;
      font-size: 1.3rem;
      font-weight: 600;
      box-shadow: var(--shadow-soft);
      cursor: pointer;
    }

    #btn-add-image:active {
      transform: scale(0.97);
    }

    /* file input overlay that covers entire screen */
    #imageInput {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    /* OCR (SCANNING + SEARCH) SCREEN */
    #screen-ocr {
      position: absolute;
      inset: 0;
      overflow: hidden;
      background: #000;
    }

    #ocr-image-wrapper {
      position: absolute;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      background: #000;
    }

    #ocr-image-wrapper img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    #ocr-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 10vw;
    }

    .scanning-label,
    .search-container {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      transition: opacity var(--transition-med), transform var(--transition-med);
      will-change: opacity, transform;
    }

    .scanning-label {
      font-size: 3rem;
      font-weight: 700;
      bottom: 20vh;
      opacity: 1;
    }

    .search-container {
      bottom: 20vh;
      width: 80vw;
      max-width: 480px;
      opacity: 0;
      pointer-events: none;
    }

    #screen-ocr.mode-search .scanning-label {
      opacity: 0;
      transform: translate(-50%, 8px);
    }

    #screen-ocr.mode-search .search-container {
      opacity: 1;
      transform: translate(-50%, 0);
      pointer-events: auto;
    }

    .search-input-wrapper {
      background: #111;
      border-radius: 999px;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      box-shadow: var(--shadow-soft);
    }

    .search-input {
      flex: 1;
      border: none;
      background: transparent;
      color: #fff;
      font-size: 1.1rem;
      outline: none;
      padding: 4px 8px;
    }

    .search-input::placeholder {
      color: rgba(255, 255, 255, 0.45);
    }

    .autosuggest {
      margin-top: 8px;
      border-radius: 24px;
      background: rgba(255, 255, 255, 0.96);
      color: #111;
      max-height: 40vh;
      overflow-y: auto;
      box-shadow: var(--shadow-soft);
      opacity: 0;
      transform: translateY(-8px);
      pointer-events: none;
      transition: opacity var(--transition-med), transform var(--transition-med);
    }

    .autosuggest.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .autosuggest-item {
      padding: 10px 16px;
      font-size: 1.0rem;
      border-bottom: 1px solid rgba(0, 0, 0, 0.08);
      cursor: pointer;
    }

    .autosuggest-item:last-child {
      border-bottom: none;
    }

    .autosuggest-item:hover {
      background: rgba(0, 0, 0, 0.04);
    }

    /* OCR progress label */
    #ocr-progress {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.75);
      font-size: 0.9rem;
      box-shadow: var(--shadow-soft);
    }

    #ocr-progress.hidden {
      display: none;
    }

    /* RESULTS SCREEN */

    #screen-results {
      display: flex;
      flex-direction: column;
      background: #000;
    }

    #results-top-row {
      padding: 16px;
      display: flex;
      justify-content: flex-start;
    }

    #btn-new-image {
      background: var(--accent);
      border: none;
      border-radius: 999px;
      padding: 12px 24px;
      font-size: 1.1rem;
      font-weight: 600;
      color: #fff;
      box-shadow: var(--shadow-soft);
      cursor: pointer;
    }

    #results-image-wrapper {
      flex: 1;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 0 8px 0;
    }

    #results-image-inner {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    #results-image {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      display: block;
    }

    .highlight-rect {
      position: absolute;
      border: 3px solid #c6ff00;
      border-radius: 8px;
      box-shadow: 0 0 18px rgba(198, 255, 0, 0.9);
      pointer-events: none;
    }

    .highlight-circle {
      position: absolute;
      border-radius: 50%;
      border: 4px solid rgba(198, 255, 0, 0.9);
      box-shadow: 0 0 45px rgba(198, 255, 0, 0.9);
      pointer-events: none;
    }

    #results-bottom-row {
      padding: 6px 16px 18px 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }

    #btn-prev,
    #btn-next {
      width: 44px;
      height: 44px;
      border-radius: 999px;
      border: none;
      background: var(--accent);
      color: #fff;
      font-weight: 700;
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow-soft);
      cursor: pointer;
      flex-shrink: 0;
    }

    #btn-prev:active,
    #btn-next:active {
      transform: scale(0.96);
    }

    #results-term-pill {
      flex: 1;
      max-width: 240px;
      text-align: center;
      padding: 10px 16px;
      border-radius: 999px;
      border: none;
      background: #fff;
      color: #000;
      font-size: 1.1rem;
      font-weight: 600;
      box-shadow: var(--shadow-soft);
    }

    /* NEW SEARCH BUTTON */
    #btn-new-search {
      position: absolute;
      bottom: 12px;
      left: 16px;
      padding: 10px 18px;
      border-radius: 999px;
      border: none;
      font-size: 1.0rem;
      background: #5a3a20;
      color: #fff;
      box-shadow: var(--shadow-soft);
      cursor: pointer;
    }

    #btn-new-search:active {
      transform: scale(0.97);
    }
  </style>
</head>
<body>
<div id="app">
  <!-- ADD IMAGE -->
  <div id="screen-add" class="screen active">
    <div id="screen-add-inner">
      <h1>spineless</h1>
      <button id="btn-add-image">new image</button>
    </div>
    <input id="imageInput" type="file" accept="image/*" />
  </div>

  <!-- OCR SCANNING + SEARCH -->
  <div id="screen-ocr" class="screen">
    <div id="ocr-image-wrapper">
      <img id="ocr-image" src="" alt="Bookshelf being scanned" />
    </div>
    <div id="ocr-overlay">
      <div id="ocr-progress" class="hidden">reading…</div>
      <div class="scanning-label">reading</div>
      <div class="search-container">
        <div class="search-input-wrapper">
          <input
            id="searchInput"
            class="search-input"
            type="text"
            placeholder="search"
            autocomplete="off"
          />
        </div>
        <div id="autosuggest" class="autosuggest"></div>
      </div>
    </div>
  </div>

  <!-- RESULTS -->
  <div id="screen-results" class="screen">
    <div id="results-top-row">
      <button id="btn-new-image">new image</button>
    </div>

    <div id="results-image-wrapper">
      <div id="results-image-inner">
        <img id="results-image" src="" alt="Bookshelf" />
        <div id="highlightRect" class="highlight-rect"></div>
        <div id="highlightCircle" class="highlight-circle"></div>
      </div>
    </div>

    <div id="results-bottom-row">
      <button id="btn-prev">&#8249;</button>
      <div id="results-term-pill"></div>
      <button id="btn-next">&#8250;</button>
      <button id="btn-new-search">new search</button>
    </div>
  </div>
</div>

<script>
  const screenAdd = document.getElementById("screen-add");
  const screenOCR = document.getElementById("screen-ocr");
  const screenResults = document.getElementById("screen-results");

  const btnAddImage = document.getElementById("btn-add-image");
  const imageInput = document.getElementById("imageInput");

  const ocrImage = document.getElementById("ocr-image");
  const ocrProgress = document.getElementById("ocr-progress");
  const searchInput = document.getElementById("searchInput");
  const autosuggestEl = document.getElementById("autosuggest");

  const resultsImage = document.getElementById("results-image");
  const highlightRect = document.getElementById("highlightRect");
  const highlightCircle = document.getElementById("highlightCircle");
  const btnPrev = document.getElementById("btn-prev");
  const btnNext = document.getElementById("btn-next");
  const btnNewImage = document.getElementById("btn-new-image");
  const btnNewSearch = document.getElementById("btn-new-search");

  const resultsTermPill = document.getElementById("results-term-pill");
  const resultsImageInner = document.getElementById("results-image-inner");

  let ocrWords = [];       // [{ text, bbox: {x0,y0,x1,y1} }] in ORIGINAL orientation
  let imageDataUrl = "";
  let matches = [];
  let matchIndex = 0;
  let currentTerm = "";

  function normalizeWord(text) {
    return (text || "")
      .trim()
      .toLowerCase()
      .replace(/^[^a-z0-9]+|[^a-z0-9]+$/gi, "")
      .trim();
  }

  function showScreen(el) {
    [screenAdd, screenOCR, screenResults].forEach((s) =>
      s.classList.remove("active")
    );
    el.classList.add("active");
  }

  // --- bbox mapping helpers ---------------------------------------- //

  // Take a bbox from a rotated canvas (kind: 'base' | 'cw' | 'ccw')
  // and map it back into the original image coordinate system.
  function mapBboxToOriginal(bbox, kind, W, H) {
    let { x0, y0, x1, y1 } = bbox;

    // corners in rotated space
    const corners = [
      [x0, y0],
      [x1, y1],
    ];

    function fromBase(u, v) {
      return { x: u, y: v };
    }

    // cw canvas width=H, height=W, created via:
    // ctx.translate(H,0); ctx.rotate(Math.PI/2); ctx.drawImage(img,0,0);
    // orig (x,y) -> cw (u,v) = (H - y, x)
    // inverse: (u,v) -> orig (x = v, y = H - u)
    function fromCW(u, v) {
      const x = v;
      const y = H - u;
      return { x, y };
    }

    // ccw canvas width=H, height=W, created via:
    // ctx.translate(0,W); ctx.rotate(-Math.PI/2); ctx.drawImage(img,0,0);
    // orig (x,y) -> ccw (u,v) = (y, W - x)
    // inverse: (u,v) -> orig (x = W - v, y = u)
    function fromCCW(u, v) {
      const x = W - v;
      const y = u;
      return { x, y };
    }

    const mapped = corners.map(([u, v]) => {
      if (kind === "base") return fromBase(u, v);
      if (kind === "cw") return fromCW(u, v);
      return fromCCW(u, v); // 'ccw'
    });

    const xs = mapped.map((p) => p.x);
    const ys = mapped.map((p) => p.y);

    let nx0 = Math.min(xs[0], xs[1]);
    let ny0 = Math.min(ys[0], ys[1]);
    let nx1 = Math.max(xs[0], xs[1]);
    let ny1 = Math.max(ys[0], ys[1]);

    // clamp to original image bounds
    nx0 = Math.max(0, Math.min(W, nx0));
    nx1 = Math.max(0, Math.min(W, nx1));
    ny0 = Math.max(0, Math.min(H, ny0));
    ny1 = Math.max(0, Math.min(H, ny1));

    return { x0: nx0, y0: ny0, x1: nx1, y1: ny1 };
  }

  // --- OCR + text extraction --------------------------------------- //

  async function runOCR(file) {
    ocrWords = [];
    ocrProgress.classList.remove("hidden");
    ocrProgress.textContent = "reading…";

    const dataUrl = await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = (e) => reject(e);
      reader.readAsDataURL(file);
    });

    imageDataUrl = dataUrl;
    ocrImage.src = dataUrl;

    // wait for image to load to get dims
    const img = await new Promise((resolve, reject) => {
      ocrImage.onload = () => resolve(ocrImage);
      ocrImage.onerror = (e) => reject(e);
    });

    const W = img.naturalWidth;
    const H = img.naturalHeight;

    // canvases for 0°, +90°, -90°
    const baseCanvas = document.createElement("canvas");
    baseCanvas.width = W;
    baseCanvas.height = H;
    const ctxBase = baseCanvas.getContext("2d");
    ctxBase.drawImage(img, 0, 0);

    const cwCanvas = document.createElement("canvas");
    cwCanvas.width = H;
    cwCanvas.height = W;
    const ctxCW = cwCanvas.getContext("2d");
    ctxCW.translate(H, 0);
    ctxCW.rotate(Math.PI / 2);
    ctxCW.drawImage(img, 0, 0);

    const ccwCanvas = document.createElement("canvas");
    ccwCanvas.width = H;
    ccwCanvas.height = W;
    const ctxCCW = ccwCanvas.getContext("2d");
    ctxCCW.translate(0, W);
    ctxCCW.rotate(-Math.PI / 2);
    ctxCCW.drawImage(img, 0, 0);

    const passes = [
      { kind: "base", canvas: baseCanvas },
      { kind: "cw", canvas: cwCanvas },
      { kind: "ccw", canvas: ccwCanvas },
    ];

    let allWords = [];

    for (let i = 0; i < passes.length; i++) {
      const { kind, canvas } = passes[i];
      const passIndex = i + 1;

      ocrProgress.textContent = `reading (${passIndex}/3)…`;

      const { data } = await Tesseract.recognize(canvas, "eng", {
        tessedit_pageseg_mode: 3,
        logger: (m) => {
          if (m.status === "recognizing text") {
            const pct = Math.round(m.progress * 100);
            ocrProgress.textContent = `reading (${passIndex}/3)… ${pct}%`;
          }
        },
      });

      const wordsRaw = data.words || [];
      const mapped = wordsRaw
        .map((w) => {
          if (!w.text || !w.bbox) return null;
          const { x0, y0, x1, y1 } = w.bbox;
          const mappedBox = mapBboxToOriginal({ x0, y0, x1, y1 }, kind, W, H);
          return {
            text: w.text,
            bbox: mappedBox,
          };
        })
        .filter(Boolean);

      allWords = allWords.concat(mapped);
    }

    ocrWords = allWords;
    ocrProgress.classList.add("hidden");

    // scanning → search transition
    screenOCR.classList.add("mode-search");
    setTimeout(() => searchInput.focus(), 450);
  }

  // --- search + autosuggest ---------------------------------------- //

  function updateAutosuggest(query) {
    if (!query) {
      autosuggestEl.classList.remove("visible");
      autosuggestEl.innerHTML = "";
      return;
    }
    const q = normalizeWord(query);
    if (!q) {
      autosuggestEl.classList.remove("visible");
      autosuggestEl.innerHTML = "";
      return;
    }
    const suggestions = Array.from(
      new Set(
        ocrWords
          .map((w) => normalizeWord(w.text))
          .filter((t) => t && t.startsWith(q))
      )
    ).slice(0, 20);

    if (!suggestions.length) {
      autosuggestEl.classList.remove("visible");
      autosuggestEl.innerHTML = "";
      return;
    }

    autosuggestEl.innerHTML = suggestions
      .map(
        (s) =>
          `<div class="autosuggest-item" data-value="${s}">${s}</div>`
      )
      .join("");
    autosuggestEl.classList.add("visible");
  }

  searchInput.addEventListener("input", (e) => {
    updateAutosuggest(e.target.value.trim());
  });

  searchInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      const term = searchInput.value.trim();
      if (term) runSearch(term);
    }
  });

  autosuggestEl.addEventListener("click", (e) => {
    const item = e.target.closest(".autosuggest-item");
    if (!item) return;
    const value = item.dataset.value;
    searchInput.value = value;
    autosuggestEl.classList.remove("visible");
    autosuggestEl.innerHTML = "";
    runSearch(value);
  });

  function runSearch(term) {
    if (!ocrWords.length) return;
    currentTerm = term;
    const q = normalizeWord(term);

    matches = ocrWords.filter(
      (w) => normalizeWord(w.text) === q
    );

    if (!matches.length) {
      alert(`No matches found for “${term}”`);
      return;
    }

    matchIndex = 0;
    setupResultsScreen();
    showScreen(screenResults);
    drawMatch();
  }

  // --- results view + highlight drawing ----------------------------- //

  function setupResultsScreen() {
    resultsImage.src = imageDataUrl;
    resultsTermPill.textContent = currentTerm || "";
  }

  function drawMatch() {
    if (!matches.length) return;
    const m = matches[matchIndex];
    const bbox = m.bbox;
    const img = resultsImage;

    if (!img.naturalWidth || !img.naturalHeight) {
      img.onload = () => drawMatch();
      return;
    }

    const displayWidth = img.clientWidth;
    const displayHeight = img.clientHeight;

    const scaleX = displayWidth / img.naturalWidth;
    const scaleY = displayHeight / img.naturalHeight;

    const x = bbox.x0 * scaleX;
    const y = bbox.y0 * scaleY;
    const w = (bbox.x1 - bbox.x0) * scaleX;
    const h = (bbox.y1 - bbox.y0) * scaleY;

    const imgRect = img.getBoundingClientRect();
    const wrapRect = resultsImageInner.getBoundingClientRect();
    const offsetLeft = imgRect.left - wrapRect.left;
    const offsetTop = imgRect.top - wrapRect.top;

    // yellow rectangle
    highlightRect.style.left = offsetLeft + x + "px";
    highlightRect.style.top = offsetTop + y + "px";
    highlightRect.style.width = Math.max(w, 16) + "px";
    highlightRect.style.height = Math.max(h, 16) + "px";

    // circle around it
    const radius = Math.max(w, h) * 1.6;
    const centerX = offsetLeft + x + w / 2;
    const centerY = offsetTop + y + h / 2;

    highlightCircle.style.width = radius + "px";
    highlightCircle.style.height = radius + "px";
    highlightCircle.style.left = centerX - radius / 2 + "px";
    highlightCircle.style.top = centerY - radius / 2 + "px";
  }

  function goNext() {
    if (!matches.length) return;
    matchIndex = (matchIndex + 1) % matches.length;
    drawMatch();
  }

  function goPrev() {
    if (!matches.length) return;
    matchIndex = (matchIndex - 1 + matches.length) % matches.length;
    drawMatch();
  }

  btnNext.addEventListener("click", goNext);
  btnPrev.addEventListener("click", goPrev);

  // swipe left/right on the image to move between matches
  let touchStartX = null;

  resultsImageInner.addEventListener("touchstart", (e) => {
    touchStartX = e.touches[0].clientX;
  });

  resultsImageInner.addEventListener("touchend", (e) => {
    if (touchStartX == null) return;
    const dx = e.changedTouches[0].clientX - touchStartX;
    if (Math.abs(dx) > 40) {
      if (dx < 0) goNext();
      else goPrev();
    }
    touchStartX = null;
  });

  // --- new image / new search -------------------------------------- //

  btnNewImage.addEventListener("click", () => {
    imageInput.value = "";
    showScreen(screenAdd);
  });

  btnNewSearch.addEventListener("click", () => {
    showScreen(screenOCR);
    screenOCR.classList.add("mode-search");
    searchInput.value = "";
    autosuggestEl.classList.remove("visible");
    setTimeout(() => searchInput.focus(), 200);
  });

  // --- initial image selection ------------------------------------- //

  btnAddImage.addEventListener("click", () => {
    imageInput.click();
  });

  imageInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return;
    showScreen(screenOCR);
    screenOCR.classList.remove("mode-search");
    runOCR(file);
  });
</script>
</body>
</html>
