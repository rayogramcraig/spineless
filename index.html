<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bookshelf Search</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Tesseract.js for OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  <style>
    :root {
      --bg-dark: #111;
      --white: #fff;
      --accent: #ff7a1a;
      --input-bg: #fff;
      --input-text: #111;
      --shadow-soft: 0 12px 30px rgba(0, 0, 0, 0.35);
      --transition-fast: 0.4s ease;
      --transition-med: 0.6s ease;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", system-ui,
        sans-serif;
      background: var(--bg-dark);
      color: var(--white);
    }

    #app {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #000;
    }

    /* Generic screen handling */
    .screen {
      position: absolute;
      inset: 0;
      display: none;
    }

    .screen.active {
      display: block;
    }

    .hidden {
      display: none !important;
    }

    /* ADD IMAGE SCREEN */
    #screen-add {
      background: #111;
      position: absolute;
      inset: 0;
    }

    #screen-add.active {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #screen-add .label {
      font-size: 3rem;
      font-weight: 700;
      pointer-events: none; /* clicks go to the overlay input */
    }

    /* Invisible file input overlay that covers entire screen */
    #imageInput {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    /* OCR (SCANNING + SEARCH) SCREEN */
    #screen-ocr {
      position: absolute;
      inset: 0;
      overflow: hidden;
      background: #000;
    }

    #ocr-bg {
      position: absolute;
      inset: 0;
      background-position: center;
      background-size: cover;
      filter: brightness(0.45);
      transform: scale(1.02);
    }

    #ocr-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 10vw;
    }

    .scanning-label,
    .search-container {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      transition: opacity var(--transition-med), transform var(--transition-med);
      will-change: opacity, transform;
    }

    .scanning-label {
      font-size: 3rem;
      font-weight: 700;
      bottom: 20vh;
      opacity: 1;
    }

    .search-container {
      bottom: 20vh;
      width: 80vw;
      max-width: 480px;
      opacity: 0;
      pointer-events: none;
      transform: translate(-50%, 20px);
    }

    .search-input {
      width: 100%;
      padding: 16px 20px;
      border-radius: 999px;
      border: none;
      font-size: 1.4rem;
      outline: none;
      background: var(--input-bg);
      color: var(--input-text);
      box-shadow: var(--shadow-soft);
    }

    .autosuggest {
      margin-top: 8px;
      border-radius: 24px;
      background: rgba(255, 255, 255, 0.96);
      color: #111;
      max-height: 40vh;
      overflow-y: auto;
      box-shadow: var(--shadow-soft);
      opacity: 0;
      transform: translateY(-8px);
      pointer-events: none;
      transition: opacity var(--transition-fast), transform var(--transition-fast);
    }

    .autosuggest.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .autosuggest-item {
      padding: 12px 18px;
      font-size: 1.4rem;
      border-bottom: 1px solid rgba(0, 0, 0, 0.08);
      cursor: pointer;
    }

    .autosuggest-item:last-child {
      border-bottom: none;
    }

    .autosuggest-item:hover {
      background: rgba(0, 0, 0, 0.04);
    }

    /* SCANNING → SEARCH TRANSITION */
    #screen-ocr.mode-search .scanning-label {
      opacity: 0;
      transform: translate(-50%, -30px);
      pointer-events: none;
    }

    #screen-ocr.mode-search .search-container {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, 0);
    }

    /* OCR progress badge */
    #ocr-progress {
      position: absolute;
      top: 24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.9rem;
      background: rgba(0, 0, 0, 0.55);
      padding: 6px 12px;
      border-radius: 999px;
      pointer-events: none;
    }

    /* RESULTS SCREEN – back to absolute layout */
    #screen-results {
      position: absolute;
      inset: 0;
      background: #000;
      color: #fff;
    }

    #results-top-row {
      position: absolute;
      top: 32px;
      left: 20px;
      z-index: 10;
    }

    #btn-new-image {
      padding: 8px 18px;
      border-radius: 999px;
      border: none;
      background: var(--accent);
      color: #fff;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      box-shadow: var(--shadow-soft);
    }

    #results-image-wrapper {
      position: absolute;
      inset: 0;
      padding: 56px 0 140px; /* space for top button + bottom pills */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #results-image-inner {
      position: relative;
      width: 100%;
      max-width: 560px;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

/* BEFORE results: image should be full viewport height */
#screen-results:not(.active) #results-image {
  height: 100vh;
  width: auto;
  object-fit: contain;
}

/* WHEN results ARE showing, behave normally */
#screen-results.active #results-image {
  max-width: 100%;
  max-height: 100%;
  width: auto;
  height: auto;
  object-fit: contain;
}

    .highlight-rect {
      position: absolute;
      border: 3px solid #ffeb3b;
      border-radius: 8px;
      pointer-events: none;
      box-shadow: 0 0 0 4px rgba(255, 235, 59, 0.25);
    }

    .highlight-circle {
      position: absolute;
      border-radius: 50%;
      border: 4px solid #dfff00;
      box-shadow: 0 0 0 4px rgba(223, 255, 0, 0.3);
      pointer-events: none;
    }

    #results-bottom {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 32px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      padding: 0 16px;
      z-index: 10;
    }

    #results-pills {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 100%;
    }

    .pill {
      flex: 1;
      max-width: 38%;
      padding: 10px 16px;
      border-radius: 999px;
      text-align: center;
      font-size: 1.3rem;
      font-weight: 700;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
    }

    .pill-side {
      background: rgba(0, 0, 0, 0.4);
      color: #fff;
      border: 2px solid rgba(255, 255, 255, 0.25);
    }

    .pill-main {
      background: var(--accent);
      color: #fff;
      border: none;
      box-shadow: var(--shadow-soft);
      pointer-events: none; /* purely visual */
    }

    #new-search-btn {
      padding: 12px 20px;
      border-radius: 999px;
      border: none;
      background: #fff;
      color: #111;
      font-size: 1.2rem;
      font-weight: 500;
      box-shadow: var(--shadow-soft);
      cursor: pointer;
      width: 70%;
      max-width: 420px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- ADD IMAGE -->
    <div id="screen-add" class="screen active">
      <input type="file" id="imageInput" accept="image/*" />
      <div class="label">add image</div>
    </div>

    <!-- OCR (SCANNING + SEARCH TRANSITION) -->
    <div id="screen-ocr" class="screen">
      <div id="ocr-bg"></div>
      <div id="ocr-overlay">
        <div id="ocr-progress" class="hidden">scanning…</div>
        <div class="scanning-label">scanning</div>

        <div class="search-container">
          <input
            id="searchInput"
            class="search-input"
            type="text"
            placeholder="search"
            autocomplete="off"
          />
          <div id="autosuggest" class="autosuggest"></div>
        </div>
      </div>
    </div>

    <!-- RESULTS -->
    <div id="screen-results" class="screen">
      <div id="results-top-row">
        <button id="btn-new-image">new image</button>
      </div>

      <div id="results-image-wrapper">
        <div id="results-image-inner">
          <img id="results-image" src="" alt="Bookshelf" />
          <div id="highlightRect" class="highlight-rect"></div>
          <div id="highlightCircle" class="highlight-circle"></div>
        </div>
      </div>

      <div id="results-bottom">
        <div id="results-pills">
          <button id="pill-left" class="pill pill-side"></button>
          <div id="pill-main" class="pill pill-main"></div>
          <button id="pill-right" class="pill pill-side"></button>
        </div>
        <button id="new-search-btn">new search</button>
      </div>
    </div>
  </div>

  <script>
    const screenAdd = document.getElementById("screen-add");
    const screenOCR = document.getElementById("screen-ocr");
    const screenResults = document.getElementById("screen-results");
    const imageInput = document.getElementById("imageInput");
    const ocrBg = document.getElementById("ocr-bg");
    const ocrProgress = document.getElementById("ocr-progress");
    const searchInput = document.getElementById("searchInput");
    const autosuggestEl = document.getElementById("autosuggest");

    const resultsImage = document.getElementById("results-image");
    const highlightRect = document.getElementById("highlightRect");
    const highlightCircle = document.getElementById("highlightCircle");
    const btnNewImage = document.getElementById("btn-new-image");
    const btnNewSearch = document.getElementById("new-search-btn");
    const pillLeft = document.getElementById("pill-left");
    const pillRight = document.getElementById("pill-right");
    const pillMain = document.getElementById("pill-main");
    const resultsImageInner = document.getElementById("results-image-inner");

    let ocrWords = [];       // [{ text, bbox: {x0,y0,x1,y1} }] in original orientation
    let imageDataUrl = "";
    let matches = [];
    let matchIndex = 0;
    let currentTerm = "";

    function showScreen(el) {
      [screenAdd, screenOCR, screenResults].forEach((s) =>
        s.classList.remove("active")
      );
      el.classList.add("active");
    }

    // --- bbox mapping helpers ---------------------------------------- //

    function mapBboxToOriginal(bbox, kind, W, H) {
      let { x0, y0, x1, y1 } = bbox;

      const corners = [
        [x0, y0],
        [x1, y1],
      ];

      function fromBase(u, v) {
        return { x: u, y: v };
      }

      // cw: orig (x,y) -> (u,v) = (H - y, x); inverse (u,v) -> (x=v, y=H-u)
      function fromCW(u, v) {
        const x = v;
        const y = H - u;
        return { x, y };
      }

      // ccw: orig (x,y) -> (u,v) = (y, W - x); inverse (u,v) -> (x=W-v, y=u)
      function fromCCW(u, v) {
        const x = W - v;
        const y = u;
        return { x, y };
      }

      const mapped = corners.map(([u, v]) => {
        if (kind === "base") return fromBase(u, v);
        if (kind === "cw") return fromCW(u, v);
        return fromCCW(u, v); // 'ccw'
      });

      const xs = mapped.map((p) => p.x);
      const ys = mapped.map((p) => p.y);

      let nx0 = Math.min(xs[0], xs[1]);
      let ny0 = Math.min(ys[0], ys[1]);
      let nx1 = Math.max(xs[0], xs[1]);
      let ny1 = Math.max(ys[0], ys[1]);

      nx0 = Math.max(0, Math.min(W, nx0));
      nx1 = Math.max(0, Math.min(W, nx1));
      ny0 = Math.max(0, Math.min(H, ny0));
      ny1 = Math.max(0, Math.min(H, ny1));

      return { x0: nx0, y0: ny0, x1: nx1, y1: ny1 };
    }

    // --- file handling ------------------------------------------------ //

    imageInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        imageDataUrl = ev.target.result;
        startOCR(imageDataUrl); // 3-pass OCR
      };
      reader.readAsDataURL(file);
    });

    // --- 3-pass OCR (base, cw, ccw) ---------------------------------- //

    async function startOCR(dataUrl) {
      showScreen(screenOCR);
      screenOCR.classList.remove("mode-search");
      ocrBg.style.backgroundImage = `url(${dataUrl})`;
      ocrProgress.classList.remove("hidden");
      ocrProgress.textContent = "scanning…";

      try {
        const img = new Image();
        img.src = dataUrl;

        await new Promise((resolve, reject) => {
          img.onload = () => resolve();
          img.onerror = (err) =>
            reject(new Error("Could not load image for OCR"));
        });

        const W = img.naturalWidth;
        const H = img.naturalHeight;

        // base canvas
        const baseCanvas = document.createElement("canvas");
        baseCanvas.width = W;
        baseCanvas.height = H;
        baseCanvas.getContext("2d").drawImage(img, 0, 0);

        // 90° clockwise
        const cwCanvas = document.createElement("canvas");
        cwCanvas.width = H;
        cwCanvas.height = W;
        const ctxCW = cwCanvas.getContext("2d");
        ctxCW.translate(H, 0);
        ctxCW.rotate(Math.PI / 2);
        ctxCW.drawImage(img, 0, 0);

        // 90° counter-clockwise
        const ccwCanvas = document.createElement("canvas");
        ccwCanvas.width = H;
        ccwCanvas.height = W;
        const ctxCCW = ccwCanvas.getContext("2d");
        ctxCCW.translate(0, W);
        ctxCCW.rotate(-Math.PI / 2);
        ctxCCW.drawImage(img, 0, 0);

        const passes = [
          { kind: "base", canvas: baseCanvas },
          { kind: "cw", canvas: cwCanvas },
          { kind: "ccw", canvas: ccwCanvas },
        ];

        let allWords = [];

        for (let i = 0; i < passes.length; i++) {
          const { kind, canvas } = passes[i];
          const passIndex = i + 1;
          const passTotal = passes.length;

          const result = await Tesseract.recognize(canvas, "eng", {
            logger: (m) => {
              if (m.status === "recognizing text") {
                const pct = Math.round((m.progress || 0) * 100);
                ocrProgress.textContent = `scanning ${passIndex}/${passTotal}… ${pct}%`;
              } else {
                ocrProgress.textContent = `scanning ${passIndex}/${passTotal}…`;
              }
            },
          });

          const words = result.data.words || [];
          const mapped = words
            .filter((w) => w.text && w.text.trim().length)
            .map((w) => ({
              text: w.text.trim(),
              bbox: mapBboxToOriginal(w.bbox, kind, W, H),
            }));

          allWords = allWords.concat(mapped);
        }

        ocrWords = allWords;
        ocrProgress.classList.add("hidden");

        // scanning → search transition
        screenOCR.classList.add("mode-search");
        setTimeout(() => searchInput.focus(), 450);
      } catch (err) {
        console.error(err);
        alert(
          "There was a problem reading the image.\n\n" +
            (err && err.message ? err.message : String(err))
        );
        showScreen(screenAdd);
      }
    }

    // --- search + autosuggest ---------------------------------------- //

    function updateAutosuggest(query) {
      if (!query) {
        autosuggestEl.classList.remove("visible");
        autosuggestEl.innerHTML = "";
        return;
      }
      const q = query.toLowerCase();
      const suggestions = Array.from(
        new Set(
          ocrWords
            .map((w) => w.text)
            .filter((t) => t.toLowerCase().startsWith(q))
        )
      ).slice(0, 20);

      if (!suggestions.length) {
        autosuggestEl.classList.remove("visible");
        autosuggestEl.innerHTML = "";
        return;
      }

      autosuggestEl.innerHTML = suggestions
        .map(
          (s) =>
            `<div class="autosuggest-item" data-value="${s}">${s}</div>`
        )
        .join("");
      autosuggestEl.classList.add("visible");
    }

    searchInput.addEventListener("input", (e) => {
      updateAutosuggest(e.target.value.trim());
    });

    searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const term = searchInput.value.trim();
        if (term) runSearch(term);
      }
    });

    autosuggestEl.addEventListener("click", (e) => {
      const item = e.target.closest(".autosuggest-item");
      if (!item) return;
      const value = item.dataset.value;
      searchInput.value = value;
      autosuggestEl.classList.remove("visible");
      runSearch(value);
    });

    function runSearch(term) {
      if (!ocrWords.length) return;
      currentTerm = term;
      const q = term.toLowerCase();

      matches = ocrWords.filter(
        (w) => w.text && w.text.toLowerCase().includes(q)
      );

      if (!matches.length) {
        alert(`No matches found for “${term}”`);
        return;
      }

      matchIndex = 0;
      setupResultsScreen();
      showScreen(screenResults);
      drawMatch();
    }

    // --- results view + highlighting --------------------------------- //

    function setupResultsScreen() {
      resultsImage.src = imageDataUrl;
      pillMain.textContent = currentTerm;
      pillLeft.textContent = currentTerm;
      pillRight.textContent = currentTerm;
    }

    function drawMatch() {
      if (!matches.length) return;
      const m = matches[matchIndex];
      const bbox = m.bbox;
      const img = resultsImage;

      if (!img.naturalWidth || !img.naturalHeight) {
        img.onload = () => drawMatch();
        return;
      }

      const displayWidth = img.clientWidth;
      const displayHeight = img.clientHeight;

      const scaleX = displayWidth / img.naturalWidth;
      const scaleY = displayHeight / img.naturalHeight;

      const x = bbox.x0 * scaleX;
      const y = bbox.y0 * scaleY;
      const w = (bbox.x1 - bbox.x0) * scaleX;
      const h = (bbox.y1 - bbox.y0) * scaleY;

      const imgRect = img.getBoundingClientRect();
      const wrapRect = resultsImageInner.getBoundingClientRect();
      const offsetLeft = imgRect.left - wrapRect.left;
      const offsetTop = imgRect.top - wrapRect.top;

      highlightRect.style.left = offsetLeft + x + "px";
      highlightRect.style.top = offsetTop + y + "px";
      highlightRect.style.width = Math.max(w, 16) + "px";
      highlightRect.style.height = Math.max(h, 16) + "px";

      const radius = Math.max(w, h) * 1.6;
      const centerX = offsetLeft + x + w / 2;
      const centerY = offsetTop + y + h / 2;

      highlightCircle.style.width = radius + "px";
      highlightCircle.style.height = radius + "px";
      highlightCircle.style.left = centerX - radius / 2 + "px";
      highlightCircle.style.top = centerY - radius / 2 + "px";
    }

    function goNext() {
      if (!matches.length) return;
      matchIndex = (matchIndex + 1) % matches.length;
      drawMatch();
    }

    function goPrev() {
      if (!matches.length) return;
      matchIndex = (matchIndex - 1 + matches.length) % matches.length;
      drawMatch();
    }

    pillLeft.addEventListener("click", goPrev);
    pillRight.addEventListener("click", goNext);

    // swipe on image to move between matches
    let touchStartX = null;
    resultsImageInner.addEventListener("touchstart", (e) => {
      touchStartX = e.touches[0].clientX;
    });

    resultsImageInner.addEventListener("touchend", (e) => {
      if (touchStartX == null) return;
      const dx = e.changedTouches[0].clientX - touchStartX;
      if (Math.abs(dx) > 40) {
        if (dx < 0) goNext();
        else goPrev();
      }
      touchStartX = null;
    });

    // --- new image / new search -------------------------------------- //

    btnNewImage.addEventListener("click", () => {
      imageInput.value = "";
      showScreen(screenAdd);
    });

    btnNewSearch.addEventListener("click", () => {
      showScreen(screenOCR);
      screenOCR.classList.add("mode-search");
      searchInput.value = "";
      autosuggestEl.classList.remove("visible");
      setTimeout(() => searchInput.focus(), 200);
    });
  </script>
</body>
</html>