<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bookshelf Search – Single Image View</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Tesseract.js v5 via CDN -->
  <script src="https://unpkg.com/tesseract.js@v5.0.0/dist/tesseract.min.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      background: #f5f5f5;
    }
    h1 {
      margin-top: 0;
      font-size: 1.4rem;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
      align-items: center;
    }
    label {
      font-size: 0.9rem;
      font-weight: 600;
    }
    input[type="file"] {
      font-size: 0.9rem;
    }
    button {
      padding: 6px 12px;
      font-size: 0.9rem;
      border-radius: 4px;
      border: 1px solid #ccc;
      background: #fff;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    #status {
      font-size: 0.85rem;
      color: #555;
      margin-top: 4px;
    }

    .layout {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    @media (min-width: 900px) {
      .layout {
        flex-direction: row;
        align-items: flex-start;
      }
    }

    .image-wrapper {
      flex: 2;
      border: 3px solid #d4ff32;
      background: #000;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      max-height: 80vh;
      overflow: hidden;
    }
    .image-inner {
      position: relative;
      display: inline-block;
      max-width: 100%;
      max-height: 100%;
    }
    #shelfImage {
      display: block;
      max-width: 100%;
      max-height: 80vh;
      height: auto;
      width: auto;
    }

    .highlight-rect {
      position: absolute;
      border: 3px solid rgba(212, 255, 50, 0.95);
      background: rgba(212, 255, 50, 0.18);
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.45);
      pointer-events: none;
      display: none;
    }
    .highlight-circle {
      position: absolute;
      border: 4px solid rgba(212, 255, 50, 0.95);
      border-radius: 50%;
      box-shadow: 0 0 14px rgba(0, 0, 0, 0.75);
      pointer-events: none;
      display: none;
    }

    .sidebar {
      flex: 1;
      min-width: 260px;
      max-width: 360px;
      padding: 8px;
      border: 1px solid #ddd;
      background: #fff;
      border-radius: 4px;
    }

    .search-row {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
    }
    .search-row input[type="text"] {
      flex: 1;
      padding: 4px 6px;
      font-size: 0.9rem;
      border-radius: 4px;
      border: 1px solid #bbb;
    }

    .results {
      max-height: 280px;
      overflow: auto;
      font-size: 0.85rem;
    }
    .result-item {
      padding: 4px 0;
      border-bottom: 1px solid #eee;
      cursor: pointer;
    }
    .result-item:hover {
      background: #f0f0f0;
    }
    .result-item.active {
      background: #f9ffcf;
    }
    .result-item strong {
      font-weight: 600;
    }
    .small {
      font-size: 0.8rem;
      color: #777;
    }
  </style>
</head>
<body>
  <h1>Bookshelf Search – Single Image View</h1>

  <div class="controls">
    <div>
      <label for="imageInput">1. Upload a bookshelf photo (unrotated)</label><br />
      <input id="imageInput" type="file" accept="image/*" />
    </div>
    <div>
      <button id="scanButton" disabled>2. Scan image (OCR: 0°, +90°, −90°)</button>
    </div>
    <div id="status"></div>
  </div>

  <div class="layout">
    <div class="image-wrapper">
      <div class="image-inner">
        <img id="shelfImage" alt="Bookshelf" />
        <div id="highlightRect" class="highlight-rect"></div>
        <div id="highlightCircle" class="highlight-circle"></div>
      </div>
    </div>

    <div class="sidebar">
      <div class="search-row">
        <input id="searchInput" type="text" placeholder="3. Search (e.g. dada, video, surrealist)" />
        <button id="searchButton" disabled>Search</button>
      </div>

      <div class="small" id="ocrSummary">No OCR data yet.</div>

      <details class="small" style="margin-top:4px; max-height:120px; overflow:auto;">
        <summary>Debug: sample recognized words</summary>
        <div id="debugWords"></div>
      </details>

      <hr />
      <div class="results" id="results"></div>
    </div>
  </div>

  <script>
    const imageInput = document.getElementById('imageInput');
    const shelfImage = document.getElementById('shelfImage');
    const highlightRect = document.getElementById('highlightRect');
    const highlightCircle = document.getElementById('highlightCircle');
    const scanButton = document.getElementById('scanButton');
    const searchInput = document.getElementById('searchInput');
    const searchButton = document.getElementById('searchButton');
    const resultsEl = document.getElementById('results');
    const statusEl = document.getElementById('status');
    const ocrSummaryEl = document.getElementById('ocrSummary');
    const debugWordsEl = document.getElementById('debugWords');

    let ocrWords = [];  // {text, bbox {x0,y0,x1,y1}, confidence, source}
    let currentImageURL = null;
    let activeBBox = null; // last highlighted bbox in original image coords

    // ---------- Load image ----------
    imageInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      if (currentImageURL) URL.revokeObjectURL(currentImageURL);
      currentImageURL = URL.createObjectURL(file);

      shelfImage.onload = () => {
        scanButton.disabled = false;
        clearHighlight();
      };
      shelfImage.src = currentImageURL;

      ocrWords = [];
      activeBBox = null;
      clearHighlight();
      resultsEl.innerHTML = '';
      debugWordsEl.textContent = '';
      ocrSummaryEl.textContent = 'Image loaded. Run OCR (0°, +90°, −90°).';
      searchButton.disabled = true;
      scanButton.disabled = true; // re-enabled when image loads
      statusEl.textContent = '';
    });

    // ---------- Image enhancement ----------
    function enhanceCanvas(canvas) {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      const contrast = 1.2;
      const middle = 128;

      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];

        let v = 0.299 * r + 0.587 * g + 0.114 * b; // luminance

        v = (v - middle) * contrast + middle;
        if (v < 0) v = 0;
        if (v > 255) v = 255;

        data[i] = data[i + 1] = data[i + 2] = v;
      }

      ctx.putImageData(imageData, 0, 0);
    }

    // ---------- Canvas + transform helpers ----------
    function createCanvasForOrientation(img, orientation) {
      const W = img.naturalWidth;
      const H = img.naturalHeight;
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      if (orientation === 'original') {
        canvas.width = W;
        canvas.height = H;
        ctx.drawImage(img, 0, 0);
        enhanceCanvas(canvas);
      } else if (orientation === 'cw') {
        canvas.width = H;
        canvas.height = W;
        ctx.translate(H, 0);
        ctx.rotate(Math.PI / 2);
        ctx.drawImage(img, 0, 0);
        enhanceCanvas(canvas);
      } else if (orientation === 'ccw') {
        canvas.width = H;
        canvas.height = W;
        ctx.translate(0, W);
        ctx.rotate(-Math.PI / 2);
        ctx.drawImage(img, 0, 0);
        enhanceCanvas(canvas);
      }

      return canvas;
    }

    function transformBboxFromCWToOriginal(bbox, origW, origH) {
      const pts = [
        { x: bbox.x0, y: bbox.y0 },
        { x: bbox.x1, y: bbox.y0 },
        { x: bbox.x0, y: bbox.y1 },
        { x: bbox.x1, y: bbox.y1 },
      ];
      const mapped = pts.map((p) => {
        const xo = p.y;
        const yo = origH - 1 - p.x;
        return { x: xo, y: yo };
      });
      const xs = mapped.map((p) => p.x);
      const ys = mapped.map((p) => p.y);
      return {
        x0: clamp(Math.min(...xs), 0, origW),
        y0: clamp(Math.min(...ys), 0, origH),
        x1: clamp(Math.max(...xs), 0, origW),
        y1: clamp(Math.max(...ys), 0, origH),
      };
    }

    function transformBboxFromCCWToOriginal(bbox, origW, origH) {
      const pts = [
        { x: bbox.x0, y: bbox.y0 },
        { x: bbox.x1, y: bbox.y0 },
        { x: bbox.x0, y: bbox.y1 },
        { x: bbox.x1, y: bbox.y1 },
      ];
      const mapped = pts.map((p) => {
        const xo = origW - 1 - p.y;
        const yo = p.x;
        return { x: xo, y: yo };
      });
      const xs = mapped.map((p) => p.x);
      const ys = mapped.map((p) => p.y);
      return {
        x0: clamp(Math.min(...xs), 0, origW),
        y0: clamp(Math.min(...ys), 0, origH),
        x1: clamp(Math.max(...xs), 0, origW),
        y1: clamp(Math.max(...ys), 0, origH),
      };
    }

    function clamp(v, min, max) {
      return Math.min(Math.max(v, min), max);
    }

    // ---------- OCR 0° / +90° / −90° ----------
    scanButton.addEventListener('click', async () => {
      if (!shelfImage.src || !shelfImage.complete) return;

      scanButton.disabled = true;
      searchButton.disabled = true;
      statusEl.textContent = 'Preparing OCR (0°, +90°, −90°)...';
      clearHighlight();
      resultsEl.innerHTML = '';
      debugWordsEl.textContent = '';
      ocrWords = [];
      activeBBox = null;

      const origW = shelfImage.naturalWidth;
      const origH = shelfImage.naturalHeight;

      try {
        const orientations = ['original', 'cw', 'ccw'];
        let totalWords = 0;
        let totalConf = 0;

        for (const orientation of orientations) {
          statusEl.textContent = `Running OCR for ${orientation}...`;
          const canvas = createCanvasForOrientation(shelfImage, orientation);

          const { data } = await Tesseract.recognize(
            canvas,
            'eng',
            {
              logger: (m) => {
                if (m.status === 'recognizing text') {
                  statusEl.textContent =
                    `Recognizing text (${orientation}): ${(m.progress * 100).toFixed(1)}%`;
                } else {
                  statusEl.textContent = m.status;
                }
              },
              tessedit_pageseg_mode: '6'
            }
          );

          const words = (data.words || [])
            .filter((w) => w.text && w.text.trim().length > 0)
            .map((w) => {
              let bboxOrig;
              if (orientation === 'original') {
                bboxOrig = w.bbox;
              } else if (orientation === 'cw') {
                bboxOrig = transformBboxFromCWToOriginal(w.bbox, origW, origH);
              } else {
                bboxOrig = transformBboxFromCCWToOriginal(w.bbox, origW, origH);
              }
              return {
                text: w.text.trim(),
                bbox: bboxOrig,
                confidence: w.confidence,
                source: orientation,
              };
            });

          words.forEach((w) => {
            totalWords += 1;
            totalConf += (w.confidence || 0);
            ocrWords.push(w);
          });
        }

        const avgConf = totalWords > 0 ? (totalConf / totalWords).toFixed(1) : '0';

        ocrSummaryEl.textContent =
          `Combined ${totalWords} words from 3 orientations (avg conf ${avgConf}). ` +
          `Search for any recognized word fragment.`;

        const sample = ocrWords.slice(0, 80).map(
          (w) => `${w.text} (${w.source})`
        );
        debugWordsEl.textContent = sample.join(' | ');

        statusEl.textContent = 'OCR complete.';
        searchButton.disabled = false;
      } catch (err) {
        console.error(err);
        statusEl.textContent = 'Error during OCR – check console.';
        scanButton.disabled = false;
      }
    });

    // ---------- Search (word-level) ----------
    searchButton.addEventListener('click', handleSearch);
    searchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') handleSearch();
    });

    function handleSearch() {
      const query = searchInput.value.trim().toLowerCase();
      clearHighlight();
      resultsEl.innerHTML = '';
      activeBBox = null;

      if (!query) return;
      if (!ocrWords.length) {
        resultsEl.innerHTML = '<div>No OCR data yet. Scan the image first.</div>';
        return;
      }

      const matches = [];
      ocrWords.forEach((w, idx) => {
        if (!w.text) return;
        if (w.text.toLowerCase().includes(query)) {
          matches.push({ index: idx, word: w });
        }
      });

      if (!matches.length) {
        resultsEl.innerHTML =
          `<div>No matches for "<strong>${escapeHTML(query)}</strong>".</div>`;
        return;
      }

      resultsEl.innerHTML = matches.map(({ index, word }, i) => `
        <div class="result-item ${i === 0 ? 'active' : ''}" data-index="${index}">
          <strong>${escapeHTML(word.text)}</strong>
          <span class="small"> (conf: ${word.confidence.toFixed(1)}, ${word.source})</span>
        </div>
      `).join('');

      resultsEl.querySelectorAll('.result-item').forEach((el) => {
        el.addEventListener('click', () => {
          const idx = parseInt(el.getAttribute('data-index'), 10);
          focusOnMatch(idx);
          resultsEl.querySelectorAll('.result-item').forEach(e => e.classList.remove('active'));
          el.classList.add('active');
        });
      });

      // auto-focus first match
      focusOnMatch(matches[0].index);
    }

    function focusOnMatch(wordIndex) {
      const word = ocrWords[wordIndex];
      if (!word) return;
      activeBBox = word.bbox;
      applyHighlight(activeBBox);
    }

    // ---------- Highlight on full image ----------
    function applyHighlight(bbox) {
      if (!bbox || !shelfImage.complete) {
        clearHighlight();
        return;
      }

      const imgRect = shelfImage.getBoundingClientRect();
      const naturalW = shelfImage.naturalWidth;
      const naturalH = shelfImage.naturalHeight;

      if (!imgRect.width || !imgRect.height || !naturalW || !naturalH) {
        clearHighlight();
        return;
      }

      const scaleX = imgRect.width / naturalW;
      const scaleY = imgRect.height / naturalH;

      const x = bbox.x0 * scaleX;
      const y = bbox.y0 * scaleY;
      const w = (bbox.x1 - bbox.x0) * scaleX;
      const h = (bbox.y1 - bbox.y0) * scaleY;

      const cx = x + w / 2;
      const cy = y + h / 2;
      const radius = Math.max(w, h) * 1.4;

      // rect
      highlightRect.style.display = 'block';
      highlightRect.style.left = `${x}px`;
      highlightRect.style.top = `${y}px`;
      highlightRect.style.width = `${w}px`;
      highlightRect.style.height = `${h}px`;

      // circle
      highlightCircle.style.display = 'block';
      highlightCircle.style.left = `${cx - radius}px`;
      highlightCircle.style.top = `${cy - radius}px`;
      highlightCircle.style.width = `${radius * 2}px`;
      highlightCircle.style.height = `${radius * 2}px`;
    }

    function clearHighlight() {
      highlightRect.style.display = 'none';
      highlightCircle.style.display = 'none';
    }

    // Reposition highlight when window size changes
    window.addEventListener('resize', () => {
      if (activeBBox) {
        applyHighlight(activeBBox);
      }
    });

    function escapeHTML(str) {
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }
  </script>
</body>
</html>
